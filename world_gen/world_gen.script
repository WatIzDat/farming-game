require("library.perlin")
local camera = require("orthographic.camera")

go.property("tile_size", 128)

local CAMERA_ID = hash("/camera")

local height = 128
local width = 128

function init(self)
    msg.post(".", "acquire_input_focus")

    self.dragged = false
    self.total_offset = vmath.vector3()

    generate_world(self)
end

function on_input(self, action_id, action)
    if action_id == hash("new_world") and action.pressed then
        generate_world(self)
    end

    if action_id == hash("camera_pan") then
        if self.dragged then
            local mouse_pos = camera.screen_to_world(CAMERA_ID, vmath.vector3(action.x, action.y, 0))
            go.set_position(mouse_pos - self.total_offset)
        end

        if action.pressed then
            self.dragged = true
            self.total_offset = camera.screen_to_world(CAMERA_ID, vmath.vector3(action.x, action.y, 0)) - go.get_position()
        elseif action.released then
            self.dragged = false
        end
    end

    if action_id == hash("till_land") and action.pressed then
        local pos = go.get_position()
        local action_coords = camera.screen_to_world(CAMERA_ID, vmath.vector3(action.x, action.y, 0)) - go.get_position()

        local tx = 1 + math.floor(action_coords.x / self.tile_size)
        local ty = 1 + math.floor(action_coords.y / self.tile_size)

        if tilemap.get_tile("#world", "ground", tx, ty) == 2 then
            tilemap.set_tile("#world", "ground", tx, ty, 3)

            self.tiles[ty][tx] = 3
        end
    end
end

function generate_world(self)
    self.tiles = {}
    local value = {}

    local seed_octave1 = rnd.number()
    local seed_octave2 = rnd.number()
    local seed_octave3 = rnd.number()

    for y = 1, height do
        self.tiles[y] = {}
        value[y] = {}

        for x = 1, width do
            local nx = x / (width / 3)
            local ny = y / (height / 3)

            local elevation = 1 * ((perlin:noise(1 * nx, 1 * ny, seed_octave1) + 1) / 2)
            + 0.5 * ((perlin:noise(2 * nx, 2 * ny, seed_octave2) + 1) / 2)
            + 0.25 * ((perlin:noise(4 * nx, 4 * ny, seed_octave3) + 1) / 2)

            elevation = elevation / (1 + 0.5 + 0.25)

            value[y][x] = (elevation * 1.2) ^ 1.35

            if value[y][x] < 0.43 then
                tilemap.set_tile("#world", "ground", x, y, 1)
                self.tiles[y][x] = 1
            else
                tilemap.set_tile("#world", "ground", x, y, 2)
                self.tiles[y][x] = 2
            end
        end
    end
end