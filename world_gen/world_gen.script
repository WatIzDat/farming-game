require("library.perlin")
local camera = require("orthographic.camera")

local CAMERA_ID = hash("/camera")

local height = 128
local width = 128

function init(self)
    msg.post(".", "acquire_input_focus")

    self.dragged = false
    self.total_offset = vmath.vector3()

    generate_world()
end

function on_input(self, action_id, action)
    if action_id == hash("new_world") and action.pressed then
        generate_world()
    end

    if action_id == hash("camera_pan") then
        if self.dragged then
            local mouse_pos = camera.screen_to_world(CAMERA_ID, vmath.vector3(action.x, action.y, 0))
            go.set_position(mouse_pos - self.total_offset)
        end

        if action.pressed then
            self.dragged = true
            self.total_offset = camera.screen_to_world(CAMERA_ID, vmath.vector3(action.x, action.y, 0)) - go.get_position()
        elseif action.released then
            self.dragged = false
        end
    end
end

function generate_world()
    local value = {}

    local seed_octave1 = rnd.number()
    local seed_octave2 = rnd.number()
    local seed_octave3 = rnd.number()

    for y = 1, height do
        value[y] = {}

        for x = 1, width do
            local nx = x / (width / 3)
            local ny = y / (height / 3)

            local elevation = 1 * ((perlin:noise(1 * nx, 1 * ny, seed_octave1) + 1) / 2)
            + 0.5 * ((perlin:noise(2 * nx, 2 * ny, seed_octave2) + 1) / 2)
            + 0.25 * ((perlin:noise(4 * nx, 4 * ny, seed_octave3) + 1) / 2)

            elevation = elevation / (1 + 0.5 + 0.25)

            value[y][x] = (elevation * 1.2) ^ 1.35

            print(value[y][x])

            if value[y][x] < 0.43 then
                tilemap.set_tile("#world", "ground", x, y, 1)
                print("water")
            else
                tilemap.set_tile("#world", "ground", x, y, 2)
                print("land")
            end
        end
    end
end